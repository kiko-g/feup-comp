MonteCarloPi {

	.construct MonteCarloPi().V {
		invokespecial(this, "<init>").V;
	}

	.method public performSingleEstimate().bool {
		t1.i32 :=.i32 0.i32 -.i32 100.i32;
		t2.i32 :=.i32 invokestatic(MathUtils, "random", t1.i32, 100.i32).i32;
		rand1.i32 :=.i32 t2.i32;
		t3.i32 :=.i32 0.i32 -.i32 100.i32;
		t4.i32 :=.i32 invokestatic(MathUtils, "random", t3.i32, 100.i32).i32;
		rand2.i32 :=.i32 t4.i32;
		t5.i32 :=.i32 rand1.i32 *.i32 rand1.i32;
		t6.i32 :=.i32 rand2.i32 *.i32 rand2.i32;
		t7.i32 :=.i32 t5.i32 +.i32 t6.i32;
		t8.i32 :=.i32 t7.i32 /.i32 100.i32;
		squareDist.i32 :=.i32 t8.i32;
		if (squareDist.i32 <.bool 100.i32) goto True0;
			in_circle.bool :=.bool false.bool;
			goto Endif0;
		True0:
			in_circle.bool :=.bool true.bool;
		Endif0:
		ret.bool in_circle.bool;
	}

	.method public estimatePi100(n.i32).i32 {
		samples_so_far.i32 :=.i32 0.i32;
		samples_in_circle.i32 :=.i32 0.i32;
		While0:
			if (samples_so_far.i32 <.bool $0.n.i32) goto Loop0;
			goto EndWhile0;
		Loop0:
			t10.bool :=.bool invokevirtual(this, "performSingleEstimate").bool;
			if (t10.bool &&.bool t10.bool) goto True1;
				goto Endif1;
			True1:
				t9.i32 :=.i32 samples_in_circle.i32 +.i32 1.i32;
				samples_in_circle.i32 :=.i32 t9.i32;
			Endif1:
			t11.i32 :=.i32 samples_so_far.i32 +.i32 1.i32;
			samples_so_far.i32 :=.i32 t11.i32;
			goto While0;
		EndWhile0:
		t12.i32 :=.i32 400.i32 *.i32 samples_in_circle.i32;
		t13.i32 :=.i32 t12.i32 /.i32 $0.n.i32;
		pi_estimate.i32 :=.i32 t13.i32;
		ret.i32 pi_estimate.i32;
	}

	.method public main(args.array.String).V {
		t14.i32 :=.i32 invokestatic(ioPlus, "requestNumber").i32;
		num_samples.i32 :=.i32 t14.i32;
		t15.MonteCarloPi :=.MonteCarloPi new(MonteCarloPi).MonteCarloPi;
		invokespecial(t15.MonteCarloPi,"<init>").V;
		t16.i32 :=.i32 invokevirtual(t15.MonteCarloPi, "estimatePi100", num_samples.i32).i32;
		pi_estimate_times_100.i32 :=.i32 t16.i32;
		invokestatic(ioPlus, "printResult", pi_estimate_times_100.i32).V;
		ret.V;
	}
}
