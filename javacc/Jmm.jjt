options {
    LOOKAHEAD = 1;
    STATIC = false;
}

PARSER_BEGIN(Jmm)
import java.util.ArrayList;
import java.util.List;
import report.Report;
import report.Stage;
import report.ReportType;

public class Jmm {
    private final List<Report> reports = new ArrayList<Report>();
    public static void main(String args[]) { }

    public void processWhileError(ParseException e) {
        Token currentToken = e.currentToken;
        Token errorToken = currentToken.next;
        this.reports.add(new Report(ReportType.ERROR, Stage.SYNTATIC, errorToken.beginLine, errorToken.endLine, getErrorMessage(this.reports.size(), errorToken, e.expectedTokenSequences, e.tokenImage)));
        recoverFromWhile();
    }

    public static String getErrorMessage(int errno, Token token,  int[][] expectedTokenSequences, String[] tokenImage) {
        int maxSize = 0;
        StringBuilder expected = new StringBuilder("\t\t");

        for (int i = 0; i < expectedTokenSequences.length; i++) {
            if (maxSize < expectedTokenSequences[i].length) {
                maxSize = expectedTokenSequences[i].length;
            }
            for (int j = 0; j < expectedTokenSequences[i].length; j++) {
                expected.append(tokenImage[expectedTokenSequences[i][j]]);
            }

            if(i != expectedTokenSequences.length - 1) {
                expected.append(" | ");
            } else {
                expected.append("\n");
            }
        }

        String info = String.format("%s\n%s\n%s",
            String.format("Error(%d) detected during parsing process. Unexpected token '%s' ....", errno, token),
            "\tError Details:",
            String.format("\t\tLine: %d \t Column: %d", token.beginLine, token.beginColumn)
        );

        return String.format("%s\n%s\n%s", info, "\tWas expecting:", expected);
      }

    public void recoverFromWhile() {
        Token t = getToken(0);
        do {
            if(t.kind == RPAR && getToken(1).kind != RPAR) { // If it finds the last ")"
                return;
            } else if(getToken(1).kind == LBRACKET) { // If it finds the first "{"
                return;
            }
            t = getNextToken();
        } while (true);
    }

    public List<Report> getReports() {
        return this.reports;
    }
}
PARSER_END(Jmm)

SKIP: {
    " " | "\t" | "\r" | "\n"
    | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >  /*multiline comment*/
    | < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> //inline comment
}

/*Reserved Words*/
TOKEN : {
    <IMPORT: "import">
    | <CLASS: "class" >
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <RETURN: "return">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <LENGTH: "length">
    | <TRUE: "true" >
    | <FALSE: "false" >
    | <THIS: "this">
    | <NEW: "new">
}

/* Delimitaters*/
TOKEN : {
    < SEMICOLON: ";">
    | < COMMA: ",">
    | < LBRACKET: "{">
    | < RBRACKET: "}">
    | < LSQRBRACKET: "[">
    | < RSQRBRACKET: "]">
    | < LPAR: "(">
    | < RPAR: ")">
    | < DOT: ".">
}

/*Operators*/
TOKEN : {
    <PLUS: "+">
    | <MINUS: "-">
    | <MUL: "*">
    | <DIV: "/">
    | <LESS: "<">
    | <AND: "&&">
    | <NOT: "!">
    | <EQUALS: "=">
}

TOKEN: {
   <IDENTIFIER: ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >

   | < INTEGER_LITERAL : <DECIMAL> | <HEXADECIMAL> | <BINARY> | <OCTAL> >
   | < #DECIMAL: (["0"-"9"])+ >
   | < #HEXADECIMAL: ("0x" | "0X")(["0"-"9", "A"-"F", "a"-"f"])+ >
   | < #BINARY: ("0b" | "0B")(["0", "1"])+ >
   | < #OCTAL: "0"(["0"-"7"])* >
}

SimpleNode Program(): { } {
    ImportDeclaration() ClassDeclaration() #Class { return jjtThis; }
}

void ImportDeclaration() #void: {} {
    (<IMPORT> ImportStatement() #Import <SEMICOLON>)*
}

void ImportStatement() #void: {} {
    Import() (<DOT>Import())*
}

Token Import() #void: {Token t;} {
    t=<IDENTIFIER> {jjtThis.put("VALUE", t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #ImportName {return t;}
}

void ClassDeclaration() #void: {} {
    <CLASS> ClassBody() <LBRACKET> (VarDeclaration() #VarDecl)* (MethodDeclaration())* <RBRACKET>
}

void ClassBody() #void: {} {
    Name() [<EXTENDS> Name()]
}

void VarDeclaration() #void: {} {
    Type() Name() <SEMICOLON>
}

void MethodDeclaration() #void: { } {
    <PUBLIC> (MainDeclaration() #Main | RegularMethodDeclaration() #Method)
}

void MainDeclaration() #void: {Token t;} {
    <STATIC> <VOID> <MAIN> <LPAR> (t=<STRING> {
        jjtThis.put("VALUE",  t.image);
        jjtThis.put("LINE",  String.valueOf(t.beginLine));
        jjtThis.put("COLUMN", String.valueOf(t.beginColumn));
    } #ClassName <LSQRBRACKET> <RSQRBRACKET>#Array(1) Name())#MethodParam(2) <RPAR>#MethodParameters(1) <LBRACKET>
        MethodBody()
    <RBRACKET>
}

void RegularMethodDeclaration() #void: {} {
    Type() Name() <LPAR> [MethodParameters()] <RPAR> <LBRACKET>
        MethodBody()
        <RETURN> Expression()#Return <SEMICOLON>
    <RBRACKET>
}

void MethodParameters() : {} {
    MethodParam() (<COMMA> MethodParam())*
}

void MethodParam() : {} {
    Type() Name()
}

void MethodBody() #void: {} {
    (LOOKAHEAD(2) VarDeclaration() #VarDecl)* (Statement())*
}

void Type() #void: {Token t;} {
    t=<BOOLEAN> {jjtThis.put("VALUE",  t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Boolean
    | t=<INT> {jjtThis.put("VALUE",  t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Int [<LSQRBRACKET> <RSQRBRACKET> #Array(1) ]
    | t=<IDENTIFIER> {jjtThis.put("VALUE",  t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #ClassName
}

void Statement() #void: {} {
    <LBRACKET> (Statement())* #StatementBlock <RBRACKET>
    | IfStatement()
    | WhileStatement()
    | AssignOrExpression() <SEMICOLON>
}

void IfStatement() #void: {Token t;} {
    <IF> t=<LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #If(3)
}

/* *
* While Recovery
* https://www.cs.purdue.edu/homes/hosking/javacc/doc/errorrecovery.html
* https://www.cs.purdue.edu/homes/hosking/javacc/doc/apiroutines.html
* */
void WhileStatement() #void: {Token t;} {
    t=<WHILE>
    try {
        t=<LPAR> Expression() <RPAR>
    } catch (ParseException e) {
        processWhileError(e);
    }
    Statement() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #While(2)
}

/* *
* EXPRESSION:
* https://introcs.cs.princeton.edu/java/11precedence/ -> Operators
* Operators listed in a javacc file go from the ones with least precedence to the ones with most precedence (from top to bottom)
* */
void Expression() #void: {} {
    LogicalAndExp()
}

void LogicalAndExp() #void: {Token t;} {
    RelationalLessExp() (t=<AND> RelationalLessExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #LogicalAnd(2))*
}

void RelationalLessExp() #void: {Token t;} {
    ArithmeticAdditiveExp() (t=<LESS> ArithmeticAdditiveExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Less(2))*
}

void ArithmeticAdditiveExp() #void: {Token t;} {
    ArithmeticMultiplicativeExp()
    (t=<PLUS> ArithmeticMultiplicativeExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Add(2)
        | t=<MINUS> ArithmeticMultiplicativeExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Sub(2))*
}

void ArithmeticMultiplicativeExp() #void: {Token t;} {
    LogicalNotExp()
    (t=<MUL> LogicalNotExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Mul(2)
        | t=<DIV> LogicalNotExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Div(2))*
}

void LogicalNotExp() #void: {Token t;} {
    (t=<NOT> AccessExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Not)+ | AccessExp()
}

void AccessExp() #void: {Token t;} {
    TerminalExp() (t=ArrayAccess() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #ArrayAccess(2) | t=<DOT> DotExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Dot(2))*
}

void DotExp() #void: {Token t;} {
    t=<LENGTH> #Length | CallWithParams() #MethodCall
}

Token ArrayAccess() #void: {Token t;} {
    t=<LSQRBRACKET> Expression() #Index <RSQRBRACKET> {return t;}
}

void CallWithParams() #void: {} {
    Name() Params()#Params
}

void TerminalExp() #void: {Token t;} {
    t=<INTEGER_LITERAL> {jjtThis.put("VALUE", t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #IntegerVal
    | t=<TRUE> {jjtThis.put("VALUE", "true"); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Bool
    | t=<FALSE> {jjtThis.put("VALUE", "false"); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Bool
    | t=<THIS> {jjtThis.put("VALUE", "this"); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #This
    | Var()
    | <NEW> NewInstance() #New
    | <LPAR> Expression() #Important <RPAR>
}

void AssignOrExpression() #void: {Token t;} {
    t=<INTEGER_LITERAL> {jjtThis.put("VALUE", t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #IntegerVal Operations()
    | t=<TRUE> {jjtThis.put("VALUE", "true"); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Bool Operations()
    | t=<FALSE> {jjtThis.put("VALUE", "false"); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Bool Operations()
    | t=<THIS> {jjtThis.put("VALUE", "this"); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #This Operations()
    | Var()  ArrayAccessExpressionOrAssign()
    | <NEW> NewInstance() #New
    | <LPAR> Expression() #Important <RPAR>
    | t=<NOT> LogicalNotExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Not
}

void ArrayAccessExpressionOrAssign() #void: {Token t;} {
    //Ignore warning, match with first ArrayAccess
    [LOOKAHEAD(1) t=ArrayAccess() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #ArrayAccess(2)]
    (
        t=<EQUALS> Expression() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}  #Assign(2)
            | Operations() (t=ArrayAccess() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #ArrayAccess(2))*
    )
}

void Operations() #void: {Token t;} {
    RelationalLessOp() (t=<AND> RelationalLessOp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}  #LogicalAnd(2))*
}

void RelationalLessOp() #void: {Token t;} {
    ArithmeticAdditiveOp() (t=<LESS> ArithmeticAdditiveOp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}  #Less(2))*
}

void ArithmeticAdditiveOp() #void: {Token t;} {
    ArithmeticMultiplicativeOp()
        (t=<PLUS> ArithmeticMultiplicativeOp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Add(2))*
        (t=<MINUS> ArithmeticMultiplicativeOp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Sub(2))*
}

void ArithmeticMultiplicativeOp() #void: {Token t;} {
    AccessOp()
    (t=<MUL> AccessOp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}  #Mul(2))*
    (t=<DIV> AccessOp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}  #Div(2))*
}

void AccessOp() #void: {Token t;} {
    (t=<DOT> DotExp() {jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));} #Dot(2))*
}

void Var(): {Token t;} {
    t=<IDENTIFIER> {jjtThis.put("VALUE", t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}
}

void Name(): {Token t;} {
    t=<IDENTIFIER> {jjtThis.put("VALUE", t.image); jjtThis.put("LINE",  String.valueOf(t.beginLine)); jjtThis.put("COLUMN", String.valueOf(t.beginColumn));}
}

void NewInstance() #void: {} {
    <INT> <LSQRBRACKET> Expression() #Size <RSQRBRACKET> #IntArray(1)
        | CallWithParams() #Object // new int[] | new Identifier(Param1, Param2, ...)
}

void Params() #void: {} {
    <LPAR> [Expression() #Param(1) (<COMMA> Expression() #Param(1))*] <RPAR>
}
