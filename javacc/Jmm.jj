options {
    LOOKAHEAD = 3;
}

PARSER_BEGIN(Jmm)
    import java.util.Scanner;
    import java.io.File;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;

    public class Jmm {
        public static void main(String args[]) throws ParseException, FileNotFoundException {
            Scanner scanner = new Scanner(System.in);
            String filename = scanner.nextLine();

            File file = new File(filename);
            FileInputStream fileStream = new FileInputStream(file);

            Jmm parser = new Jmm(fileStream);
            parser.Expression();
        }
    }
PARSER_END(Jmm)


SKIP: {
    " " | "\t" | "\r" | "\n"
    | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >  /*multiline comment*/
    | < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> //inline comment
}

/*Reserved Words*/
TOKEN :
{
    <IMPORT: "import">
    | <CLASS: "class" >
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <RETURN: "return">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <LENGTH: "length">
    | <TRUE: "true" >
    | <FALSE: "false" >
    | <THIS: "this">
    | <NEW: "new">
}

/* Delimitaters*/
TOKEN : {
    < SEMICOLON: ";">
    | < COMMA: ",">
    | < LBRACKET: "{">
    | < RBRACKET: "}">
    | < LSQRBRACKET: "[">
    | < RSQRBRACKET: "]">
    | < LPAR: "(">
    | < RPAR: ")">
    | < DOT: ".">
}

/*Operators*/
TOKEN : {
    <PLUS: "+">
    | <MINUS: "-">
    | <MUL: "*">
    | <DIV: "/">
    | <LESS: "<">
    | <AND: "&&">
    | <NOT: "!">
    | <EQUALS: "=">
}

TOKEN:
{
   <IDENTIFIER: ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >

   | < INTEGER_LITERAL : <DECIMAL> | <HEXADECIMAL> | <BINARY> | <OCTAL> >
   | < #DECIMAL: (["0"-"9"])+ >
   | < #HEXADECIMAL: ("0x" | "0X")(["0"-"9", "A"-"F", "a"-"f"])+ >
   | < #BINARY: ("0b" | "0B")(["0", "1"])+ >
   | < #OCTAL: "0"(["0"-"7"])* >
}

void Program(): { } {
    ImportDeclaration() ClassDeclaration() <EOF>
}

void ImportDeclaration() : {} {
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {} {
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <LBRACKET> (VarDeclaration())*   (MethodDeclaration())* <RBRACKET>
}

void VarDeclaration() : {} {
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {} {
    <PUBLIC> Type() <IDENTIFIER> <LPAR> [Type() <IDENTIFIER>  (<COMMA> Type() <IDENTIFIER>)* ] <RPAR> <LBRACKET>
        (VarDeclaration())* (Statement())* <RETURN> Expression() <SEMICOLON> <RBRACKET>
    | <PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQRBRACKET> <RSQRBRACKET> <IDENTIFIER> <RPAR> <LBRACKET>
        (VarDeclaration())* (Statement())*  <RBRACKET>
}

void Type() : {} {
   <INT> [<LSQRBRACKET> <RSQRBRACKET>] | <BOOLEAN> | <IDENTIFIER> | <STRING>
}

void Statement() : {} {
    <LBRACKET> (Statement())* <RBRACKET>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    | Expression() <SEMICOLON>
    | <IDENTIFIER> [<LSQRBRACKET> Expression() <RSQRBRACKET>] <EQUALS> Expression() <SEMICOLON>
}

void Expression() : {} {
    ExpressionFragment() ( "&&" | "<" | "+" | "-" | "*" | "/" ) Expression()
    | ExpressionFragment() "[" Expression() "]"
    | ExpressionFragment() "." "length"
    | ExpressionFragment() "." <IDENTIFIER> "(" [ Expression() ("," Expression())* ] ")"
    | ExpressionFragment()
}

void ExpressionFragment() : {} {
    <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <NEW> <INT> <LSQRBRACKET> Expression() <RSQRBRACKET>
    | <NEW> <IDENTIFIER> <LPAR> <RPAR>
    | <NOT> Expression()
    | <LPAR> Expression() <RPAR>
}
